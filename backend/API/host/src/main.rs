// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{GUEST_CODE_FOR_ZK_PROOF_ELF, GUEST_CODE_FOR_ZK_PROOF_ID};
use risc0_zkvm::{default_prover, ExecutorEnv};
use axum::{
    extract::Json,
    routing::{get},
    Router,
};
use serde::{Deserialize, Serialize};
use serde_json::json;

/// Struct to represent the incoming JSON request
#[derive(Debug, Deserialize)]
struct UserRequest {
    is_compliant: bool,
}

/// Struct to represent the outgoing JSON response (optional but idiomatic)
#[derive(Debug, Serialize)]
struct UserResponse {
    proven_is_compliant: bool,
    message: String,
}

#[tokio::main]
async fn main() {
    let app = Router::new()
        .route("/", get(root))
        .route(
            "/validate_user",
            get(get_validate_user).post(post_validate_user),
        );

    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000")
        .await
        .unwrap();

    println!("ðŸš€ Axum running on http://localhost:3000");

    axum::serve(listener, app).await.unwrap();
}

// GET /
async fn root() -> Json<serde_json::Value> {
    Json(json!({
        "message": "Welcome to the compliance API!"
    }))
}

// GET /validate_user
async fn get_validate_user() -> Json<serde_json::Value> {
    Json(json!({
        "message": "Send a POST request with { \"is_compliant\": true | false }"
    }))
}

// POST /validate_user
async fn post_validate_user(
    Json(payload): Json<UserRequest>,
) -> Json<UserResponse> {

    // Call the prover
    let proven_result = prove_compliance(payload.is_compliant)
        .expect("zk proof failed");

    Json(UserResponse {
        proven_is_compliant: proven_result,
        message: "Compliance proven with zkVM.".to_string(),
    })
}

pub fn prove_compliance(is_compliant: bool) -> anyhow::Result<bool> {
    // An executor environment describes the configurations for the zkVM
    // Data could be encrypted later
    let env = ExecutorEnv::builder()
        .write(&is_compliant)
        .unwrap()
        .build()
        .unwrap();

    let prover = default_prover();

    // Prove information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover
        .prove(env, GUEST_CODE_FOR_ZK_PROOF_ELF)
        .unwrap();

    let receipt = prove_info.receipt;

    // Extract journal of receipt (i.e. output c, where c = a * b)
    let result: bool = receipt.journal.decode().expect(
        "Journal output should deserialize into the same types (& order) that it was written",
    );
    if !result {
        eprintln!("Guest failed to prove validity. Input {} is invalid.", is_compliant);
    }
    println!("I know the result of validity, and I can prove it!");
    println!("Input {} is valid? {}", is_compliant, result);

    // The receipt was verified at the end of proving
    // receipt
    //     .verify(GUEST_CODE_FOR_ZK_PROOF_ID)
    //     .unwrap();
    receipt.verify(GUEST_CODE_FOR_ZK_PROOF_ID).expect(
            "Code you have proven should successfully verify; did you specify the correct image ID?",
    );
    
    Ok(result)
}

// fn main() {
//     // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
//     tracing_subscriber::fmt()
//         .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
//         .init();

//     prove_compliance(true);
// }
